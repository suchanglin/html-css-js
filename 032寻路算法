最近在做百度前端技术学院第二阶段的《听指令的小方块》这个任务时，遇到了要写一个寻路算法，于是便研究了一下。

寻路算法指的是已知起点A、终点B，在不穿过障碍物的情况下，找到由A到B的最短路径。

传统的寻路算法一般是按照单元格来划分地图，寻路算法包括A 、递归、非递归、广度优先、深度优先、使用堆栈等。这篇博客介绍的是A算法。

一. A* 算法的原理

首先，我们需要用到一个公式：

F = G + H
F为从起点经过该点的到终点总路程
G为从起点到该点的路程，称为“已走路程”->不需要考虑障碍物，可沿斜方移动
H为从该点到终点的路程，称为“预计路程”->不需要考虑障碍物，只考虑水平、垂直移动
A* 算法是从起点开始，然后检测每一个节点，直到找到终点。

我们需要两个列表：开启列表和关闭列表。

开启列表：每检测一个节点，将节点放到开启列表，将该节点周围的节点（不包括障碍物、已关闭的节点）放到开启列表中，将A存到父节点中；

关闭列表：检测完了之后，把检测完了的节点放到关闭列表。

http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html

每检测一个节点时，需要计算开启列表中的所有节点的F值，选取一个F值最小的节点，作为下一个检测节点，开启其周围的节点。

若周围的节点已经存在在开启列表中，计算新的G值（经过前面两点到此点的值），若新G值更低，计算F；若新G值更高，则不做计算。

对每一个节点都做这个操作，直到找到终点为止。

路径：沿着父节点进行运动，就是最短路径。

把起始格添加到 "开启列表" 
do 
{ 
   寻找开启列表中F值最低的格子, 我们称它为当前格. 
   把它切换到关闭列表. 
   对当前格相邻的8格中的每一个 
  if (它不可通过 || 已经在 "关闭列表" 中) 
  { 
        什么也不做. 
  } 
  if (它不在开启列表中) 
  { 
    把它添加进 "开启列表", 把当前格作为这一格的父节点, 计算这一格的 FGH 
      if (它已经在开启列表中) 
       { 
        if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
        { 
            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
           } 
     } 
    while( 目标格已经在 "开启列表", 这时候路径被找到) 
    如果开启列表已经空了, 说明路径不存在.

最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.
二. 使用寻路算法做的一个小游戏

demo地址：http://panpanfish.com/myDemo/task3-46.html

代码地址：
https://github.com/panpan040828/myDemo/blob/master/task3-46.html
